---
alwaysApply: true
---
# 脚本规则 - 最高优先级

## 核心约束（强制）

1. **所有调试操作必须使用项目中已有的脚本**，禁止手动执行命令
2. 如果脚本无法完成工作，**必须修改脚本**使其正常工作
3. AI必须主动执行脚本，不要求用户操作
4. **所有脚本必须支持跨平台**，必须提供 Windows、macOS 和 Linux 的入口脚本
5. **临时使用的脚本必须放到 `scripts/temp/` 目录**，并添加到 `.gitignore`
6. **脚本中禁止提供交互操作**（如 `input()`、`Read-Host`、`read` 等），因为脚本需要同时支持人类和AI使用，而AI的交互操作能力很差

## 脚本设计原则（指导性）

### 1. 模块化设计

- **原则：** 脚本应该尽量模块化，每个脚本负责单一职责
- **目标：** 提高脚本的可维护性和可复用性
- **实践：** 将复杂的操作拆分为多个独立的脚本模块

### 2. 单点可复用

- **原则：** 功能应该是单点可复用的，避免重复编写相同逻辑
- **示例：** 
  - 部署脚本应该**调用**构建脚本，而不是重复编写构建逻辑
  - 构建脚本应该**调用**清理脚本，而不是重复编写清理逻辑
  - 启动脚本应该**调用**部署脚本，而不是重复编写部署逻辑
- **目标：** 确保每个功能只在一个地方实现，便于维护和更新
- **实践：** 
  ```bash
  # ✅ 好的做法 - 部署脚本调用其他脚本
  ./scripts/build.sh
  ./scripts/deploy.sh
  ./scripts/start.sh
  
  # ❌ 不好的做法 - 在部署脚本中重复编写构建逻辑
  # 直接在 deploy.sh 中写构建命令
  ```

### 3. 跨平台支持（强制）

- **原则：** 所有脚本必须支持跨平台，提供各平台的入口脚本
- **目标：** 确保脚本在 Windows、macOS 和 Linux 上都能正常工作
- **实现方式：**
  - **推荐：** 使用跨平台语言（如 Python）实现核心逻辑，各平台提供代理入口脚本
  - **备选：** 使用平台特定的脚本语言，但必须提供所有平台的版本

#### 平台代理入口脚本模式（推荐）

**核心实现：** 使用 Python 等跨平台语言实现核心逻辑
**入口脚本：** 各平台提供简单的代理脚本调用核心实现

**目录结构：**
```
scripts/
├── build.py              # 核心实现（Python，跨平台）
├── build.sh              # macOS/Linux 入口脚本
├── build.bat             # Windows 入口脚本
├── deploy.py             # 核心实现
├── deploy.sh             # macOS/Linux 入口脚本
└── deploy.bat            # Windows 入口脚本
```

**Windows 入口脚本示例（build.bat）：**
```batch
@echo off
REM 获取脚本所在目录
set SCRIPT_DIR=%~dp0
REM 使用虚拟环境的 Python 运行核心脚本
"%SCRIPT_DIR%..\.venv\Scripts\python.exe" "%SCRIPT_DIR%build.py" %*
```

**macOS/Linux 入口脚本示例（build.sh）：**
```bash
#!/bin/bash
# 获取脚本所在目录
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# 使用虚拟环境的 Python 运行核心脚本
exec "$SCRIPT_DIR/../.venv/bin/python" "$SCRIPT_DIR/build.py" "$@"
```

**核心脚本示例（build.py）：**
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
跨平台构建脚本
"""
import sys
from pathlib import Path

def main():
    # 跨平台路径处理
    script_dir = Path(__file__).parent.resolve()
    project_root = script_dir.parent
    
    # 跨平台命令执行
    # ... 构建逻辑 ...
    pass

if __name__ == '__main__':
    main()
```

### 4. 脚本目录组织（强制）

- **原则：** 脚本必须按用途分类组织，临时脚本必须单独存放
- **目标：** 保持脚本目录清晰，区分正式脚本和临时脚本
- **目录结构：**
  ```
  scripts/
  ├── build.py              # 正式脚本
  ├── build.sh
  ├── build.bat
  ├── deploy.py
  ├── deploy.sh
  ├── deploy.bat
  ├── lib/                   # 脚本库（可复用模块）
  │   └── version_manager.py
  └── temp/                  # 临时脚本目录（不提交到版本控制）
      ├── .gitkeep           # 保持目录存在
      └── debug_xxx.py       # 临时调试脚本
  ```

#### 临时脚本规则

**临时脚本定义：**
- 用于一次性调试或测试的脚本
- 用于临时解决特定问题的脚本
- 用于实验性功能的脚本
- 不确定是否需要长期保留的脚本

**临时脚本存放规则：**
- ✅ **必须放在 `scripts/temp/` 目录**
- ✅ **必须添加到 `.gitignore`**，不提交到版本控制
- ✅ 临时脚本使用完毕后，应该及时清理
- ✅ 如果临时脚本需要长期使用，应该移动到正式脚本目录

**`.gitignore` 配置：**
```
# 临时脚本目录
scripts/temp/*
!scripts/temp/.gitkeep
```

### 5. 非交互式设计（强制）

- **原则：** 所有脚本必须完全非交互式，禁止任何形式的用户交互操作
- **原因：** 脚本需要同时支持人类和AI使用，而AI的交互操作能力很差，无法处理交互式输入
- **目标：** 确保脚本可以被AI自动执行，无需人工干预

#### 禁止的交互操作

| 语言 | 禁止的命令 |
|-----|----------|
| Python | `input()`, `raw_input()` |
| PowerShell | `Read-Host`, `$host.UI.PromptForChoice()` |
| Bash/Shell | `read`, `read -p`, `select` |
| Batch | `set /p`, `pause` |

#### 替代方案

**使用命令行参数：**
```python
# ✅ 好的做法 - 使用命令行参数
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('--version', required=True, help='版本号')
args = parser.parse_args()
version = args.version

# ❌ 不好的做法 - 使用交互式输入
version = input("请输入版本号: ")
```

**使用环境变量：**
```bash
# ✅ 好的做法 - 使用环境变量
VERSION=${VERSION:-"1.0.0"}  # 提供默认值
echo "版本号: $VERSION"

# ❌ 不好的做法 - 使用交互式输入
read -p "请输入版本号: " VERSION
```

**使用配置文件或默认值：**
```python
# ✅ 好的做法 - 提供默认值
version = os.getenv('VERSION', '1.0.0')

# ❌ 不好的做法 - 必须用户输入
version = input("请输入版本号: ")
```

## 禁止行为

- ❌ 手动执行构建工具命令（build、run、install等）
- ❌ 手动使用系统命令收集日志
- ❌ 手动访问日志文件路径
- ❌ 不使用预置脚本进行任何调试操作
- ❌ 要求用户手动执行命令
- ❌ 绕过脚本直接操作
- ❌ 脚本失败后不使用脚本，改为手动执行命令
- ❌ 要求用户手动修复脚本
- ❌ **只提供单一平台的脚本**（必须支持 Windows、macOS、Linux）
- ❌ **将临时脚本放在 `scripts/` 根目录**（必须放在 `scripts/temp/` 目录）
- ❌ **将临时脚本提交到版本控制**（必须添加到 `.gitignore`）
- ❌ **在脚本中使用交互操作**

## 必须遵守

- ✅ 所有部署必须使用部署脚本
- ✅ 所有日志收集必须使用日志收集脚本
- ✅ 脚本出现问题必须立即修复
- ✅ 修复脚本是AI的责任，不得推给用户
- ✅ AI必须主动执行脚本，不要求用户操作
- ✅ **所有脚本必须提供跨平台支持**（Windows、macOS、Linux）
- ✅ **临时脚本必须放在 `scripts/temp/` 目录**
- ✅ **所有脚本必须完全非交互式**

## 脚本维护规则（强制）

**如果预置脚本无法完成工作，必须修改脚本使其符合预期正常工作。**

### 脚本问题处理流程

1. **发现问题：** 当脚本执行失败或无法完成预期功能时
2. **分析问题：** 检查脚本错误信息，定位问题原因
3. **修复脚本：** 直接修改脚本文件，使其能够正常工作
4. **验证修复：** 重新执行脚本，确保问题已解决
5. **继续工作：** 使用修复后的脚本继续完成调试任务
